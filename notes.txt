# create two dataframes, for target 0 and target 1
data_0 = data[data['target'] == 0]
data_0 = data_0.drop(['target'], axis=1)
data_1 = data[data['target'] == 1]
data_1 = data_1.drop(['target'], axis=1)

df['patient'] = i
df['days'] = df_scores['days'][i+22]
df['gender'] = df_scores['gender'][i+22]
df['age'] = df_scores['age'][i+22]
df['afftype'] = df_scores['afftype'][i+22]
df['melanch'] = df_scores['melanch'][i+22]
df['inpatient'] = df_scores['inpatient'][i+22]
df['edu'] = df_scores['edu'][i+22]
df['marriage'] = df_scores['marriage'][i+22]
df['work'] = df_scores['work'][i+22]
df['madrs1'] = df_scores['madrs1'][i+22]
df['madrs2'] = df_scores['madrs2'][i+22]

--------------------------------------------
X = data.drop('target', axis=1)
y = data['target']

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
X = scaler.fit_transform(X)

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

import torch
import torch.nn as nn
import torch.nn.functional as F

class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.conv1 = nn.Conv1d(1, 32, 2)
        self.fc1 = nn.Linear(32 * (X_train.shape[1] - 1), 64)
        self.fc2 = nn.Linear(64, 1)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = x.view(-, 32 * (X_train.shape[1] - 1))
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x

net = Net()


# In this model, the nn.Conv1d layer your 1D CNN. The view function flattens the output of the CNN
# so that it can be fed into the nn.Linear, which form the simple neural network.

______________________________________________________________
print(X)
print(X.shape)
print(y.shape)
print(X[0].shape)
print(X[0].unsqueeze(0).shape)

torch.Size([55, 446])
torch.Size([55])
torch.Size([446])
torch.Size([1, 446])


--------------------------------------------------------------
criterion = nn.CrossEntropyLoss()  # Use CrossEntropyLoss for a classification problem
optimizer = optim.Adam(net.parameters())

# Reshape the data to fit the model
X_train = X_train.reshape(X_train.shape[0], 1, X_train.shape[1])
X_test = X_test.reshape(X_test.shape[0], 1, X_test.shape[1])

# Convert data to tensors
X_train = torch.tensor(X_train, dtype=torch.float32)
y_train = torch.tensor(y_train, dtype=torch.long)  # Use torch.long for labels
X_test = torch.tensor(X_test, dtype=torch.float32)
y_test = torch.tensor(y_test, dtype=torch.long)

# Train the model
for epoch in range(10):  # loop over the dataset multiple times
    running_loss = 0.0
    for i in range(len(X_train)):
        # zero the parameter gradients
        optimizer.zero_grad()

        # forward + backward + optimize
        outputs = net(X_train[i])
        loss = criterion(outputs, y_train[i])
        loss.backward()
        optimizer.step()

        # print statistics
        running_loss += loss.item()
    print('Epoch: %d loss: %.3f' % (epoch + 1, running_loss / len(X_train)))

print('Finished Training')


===============================================================================


data3 = pd.DataFrame()

for i in range(1, 56):
    df = data2[data2['patient'] == i]
    df = df.reset_index(drop=True)
    #print(df)
    #print(len(df))
    if len(df) % 48 != 0:
        df = df.drop(df.index[len(df) - len(df) % 48:])
    #print(len(df))
    df['patient'] = i
    #print(df)
    data3 = pd.concat([data3, df], axis=0)


data3 = data3.reset_index(drop=True)
print(data3)
data3.to_csv('Data/action_cnn.csv', index=False)

# find the index for the first and the last day for every patient

